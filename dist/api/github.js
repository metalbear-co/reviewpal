"use strict";
/**
 * GitHub API Integration
 *
 * Post inline comments on PRs, create reviews, and manage discussions.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubRateLimiter = void 0;
exports.createPRReview = createPRReview;
exports.postInlineComment = postInlineComment;
exports.upsertPRComment = upsertPRComment;
exports.getPRFiles = getPRFiles;
const friendly_js_1 = require("../formatters/friendly.js");
/**
 * Create a GitHub review with inline comments
 */
async function createPRReview(config, result, options = {}) {
    const { postInline = true, summaryOnly = false, maxComments = 10 } = options;
    const comments = [];
    if (postInline && !summaryOnly) {
        // Collect inline comments for each file/hunk with issues
        for (const file of result.files) {
            for (const hunk of file.hunks) {
                const hasIssues = (hunk.complexity && hunk.complexity.score > 5) ||
                    (hunk.patterns && hunk.patterns.patternsFound.length > 0);
                if (hasIssues && comments.length < maxComments) {
                    const body = (0, friendly_js_1.formatFriendlyInlineComment)(hunk, hunk.hunk.startLine);
                    if (body.trim()) {
                        comments.push({
                            path: file.filename,
                            line: hunk.hunk.startLine,
                            side: 'RIGHT',
                            body
                        });
                    }
                }
            }
        }
    }
    // Build review body summary
    const summaryBody = buildReviewSummary(result, comments.length);
    // Create the review
    const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/reviews`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${config.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            body: summaryBody,
            event: 'COMMENT',
            comments
        })
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`GitHub API error: ${response.status} - ${error}`);
    }
    const data = await response.json();
    return {
        reviewId: data.id,
        commentCount: comments.length
    };
}
/**
 * Build a summary for the PR review body
 */
function buildReviewSummary(result, inlineCount) {
    const parts = [];
    parts.push('## üîç AI Review Helper Analysis');
    parts.push('');
    // Quick stats
    const complexFiles = result.files.filter(f => f.overallComplexity > 5).length;
    const patternCount = result.files.reduce((sum, f) => sum + f.hunks.reduce((hSum, h) => hSum + (h.patterns?.patternsFound.length || 0), 0), 0);
    const hasIssues = complexFiles > 0 || patternCount > 0;
    if (!hasIssues) {
        parts.push('‚ú® **Looking good!** No major concerns found in this PR.');
        parts.push('');
        parts.push(`- Files analyzed: ${result.files.length}`);
        parts.push(`- Changes reviewed: ${result.totalHunks}`);
        parts.push(`- Time: ${(result.totalProcessingTime / 1000).toFixed(1)}s`);
    }
    else {
        parts.push('Found a few things worth reviewing:');
        parts.push('');
        if (complexFiles > 0) {
            parts.push(`- **${complexFiles}** ${complexFiles === 1 ? 'file has' : 'files have'} high complexity`);
        }
        if (patternCount > 0) {
            parts.push(`- **${patternCount}** AI pattern${patternCount === 1 ? '' : 's'} detected`);
        }
        if (inlineCount > 0) {
            parts.push('');
            parts.push(`üìù See ${inlineCount} inline comment${inlineCount === 1 ? '' : 's'} for specific suggestions.`);
        }
    }
    parts.push('');
    parts.push('---');
    parts.push('<sub>ü§ñ Generated by ReviewPal | [Configuration](https://github.com/Arephan/reviewpal)</sub>');
    return parts.join('\n');
}
/**
 * Post a single inline comment (for testing or manual use)
 */
async function postInlineComment(config, path, line, body, commitId) {
    const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/comments`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${config.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            body,
            commit_id: commitId,
            path,
            line,
            side: 'RIGHT'
        })
    });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`GitHub API error: ${response.status} - ${error}`);
    }
    const data = await response.json();
    return { id: data.id };
}
/**
 * Update or create a PR comment (for summary updates)
 */
async function upsertPRComment(config, body, marker = '<!-- ai-review-helper -->') {
    // Find existing comment
    const commentsResponse = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/issues/${config.pullNumber}/comments`, {
        headers: {
            'Authorization': `Bearer ${config.token}`,
            'Accept': 'application/vnd.github.v3+json'
        }
    });
    if (!commentsResponse.ok) {
        throw new Error(`Failed to fetch comments: ${commentsResponse.status}`);
    }
    const comments = await commentsResponse.json();
    const existingComment = comments.find(c => c.body.includes(marker));
    const fullBody = `${marker}\n\n${body}`;
    if (existingComment) {
        // Update existing comment
        const updateResponse = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/issues/comments/${existingComment.id}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${config.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ body: fullBody })
        });
        if (!updateResponse.ok) {
            throw new Error(`Failed to update comment: ${updateResponse.status}`);
        }
        return { id: existingComment.id, created: false };
    }
    else {
        // Create new comment
        const createResponse = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/issues/${config.pullNumber}/comments`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${config.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ body: fullBody })
        });
        if (!createResponse.ok) {
            throw new Error(`Failed to create comment: ${createResponse.status}`);
        }
        const data = await createResponse.json();
        return { id: data.id, created: true };
    }
}
/**
 * Get changed files in a PR
 */
async function getPRFiles(config) {
    const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/files`, {
        headers: {
            'Authorization': `Bearer ${config.token}`,
            'Accept': 'application/vnd.github.v3+json'
        }
    });
    if (!response.ok) {
        throw new Error(`Failed to fetch PR files: ${response.status}`);
    }
    const files = await response.json();
    return files.map(f => ({
        filename: f.filename,
        patch: f.patch || '',
        additions: f.additions,
        deletions: f.deletions
    }));
}
/**
 * Rate limiter for GitHub API
 */
class GitHubRateLimiter {
    remaining = 5000;
    resetTime = Date.now() + 3600000;
    async checkLimit() {
        if (this.remaining < 10) {
            const waitTime = this.resetTime - Date.now();
            if (waitTime > 0) {
                console.warn(`GitHub API rate limit low. Waiting ${Math.ceil(waitTime / 1000)}s...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
        return true;
    }
    updateFromHeaders(headers) {
        const remaining = headers.get('x-ratelimit-remaining');
        const reset = headers.get('x-ratelimit-reset');
        if (remaining)
            this.remaining = parseInt(remaining, 10);
        if (reset)
            this.resetTime = parseInt(reset, 10) * 1000;
    }
}
exports.GitHubRateLimiter = GitHubRateLimiter;
//# sourceMappingURL=github.js.map