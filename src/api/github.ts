/**
 * GitHub API Integration
 * 
 * Post inline comments on PRs, create reviews, and manage discussions.
 */

import { HunkAnalysis, FileAnalysis, ReviewResult } from '../types.js';
import { formatFriendlyInlineComment } from '../formatters/friendly.js';

interface GitHubConfig {
  token: string;
  owner: string;
  repo: string;
  pullNumber: number;
}

interface ReviewComment {
  path: string;
  line: number;
  side: 'LEFT' | 'RIGHT';
  body: string;
}

interface PendingReview {
  body: string;
  event: 'COMMENT' | 'APPROVE' | 'REQUEST_CHANGES';
  comments: ReviewComment[];
}

/**
 * Create a GitHub review with inline comments
 */
export async function createPRReview(
  config: GitHubConfig,
  result: ReviewResult,
  options: {
    postInline?: boolean;
    summaryOnly?: boolean;
    maxComments?: number;
  } = {}
): Promise<{ reviewId: number; commentCount: number }> {
  const { postInline = true, summaryOnly = false, maxComments = 10 } = options;
  
  const comments: ReviewComment[] = [];
  
  if (postInline && !summaryOnly) {
    // Collect inline comments for each file/hunk with issues
    for (const file of result.files) {
      for (const hunk of file.hunks) {
        const hasIssues = 
          (hunk.complexity && hunk.complexity.score > 5) ||
          (hunk.patterns && hunk.patterns.patternsFound.length > 0);
        
        if (hasIssues && comments.length < maxComments) {
          const body = formatFriendlyInlineComment(hunk, hunk.hunk.startLine);
          
          if (body.trim()) {
            comments.push({
              path: file.filename,
              line: hunk.hunk.startLine,
              side: 'RIGHT',
              body
            });
          }
        }
      }
    }
  }
  
  // Build review body summary
  const summaryBody = buildReviewSummary(result, comments.length);
  
  // Create the review
  const response = await fetch(
    `https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/reviews`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${config.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        body: summaryBody,
        event: 'COMMENT',
        comments
      })
    }
  );
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error: ${response.status} - ${error}`);
  }
  
  const data = await response.json() as { id: number };
  
  return {
    reviewId: data.id,
    commentCount: comments.length
  };
}

/**
 * Build a summary for the PR review body
 */
function buildReviewSummary(result: ReviewResult, inlineCount: number): string {
  const parts: string[] = [];
  
  parts.push('## üîç AI Review Helper Analysis');
  parts.push('');
  
  // Quick stats
  const complexFiles = result.files.filter(f => f.overallComplexity > 5).length;
  const patternCount = result.files.reduce((sum, f) => 
    sum + f.hunks.reduce((hSum, h) => hSum + (h.patterns?.patternsFound.length || 0), 0)
  , 0);
  
  const hasIssues = complexFiles > 0 || patternCount > 0;
  
  if (!hasIssues) {
    parts.push('‚ú® **Looking good!** No major concerns found in this PR.');
    parts.push('');
    parts.push(`- Files analyzed: ${result.files.length}`);
    parts.push(`- Changes reviewed: ${result.totalHunks}`);
    parts.push(`- Time: ${(result.totalProcessingTime / 1000).toFixed(1)}s`);
  } else {
    parts.push('Found a few things worth reviewing:');
    parts.push('');
    
    if (complexFiles > 0) {
      parts.push(`- **${complexFiles}** ${complexFiles === 1 ? 'file has' : 'files have'} high complexity`);
    }
    
    if (patternCount > 0) {
      parts.push(`- **${patternCount}** AI pattern${patternCount === 1 ? '' : 's'} detected`);
    }
    
    if (inlineCount > 0) {
      parts.push('');
      parts.push(`üìù See ${inlineCount} inline comment${inlineCount === 1 ? '' : 's'} for specific suggestions.`);
    }
  }
  
  parts.push('');
  parts.push('---');
  parts.push('<sub>ü§ñ Generated by ReviewPal | [Configuration](https://github.com/Arephan/reviewpal)</sub>');
  
  return parts.join('\n');
}

/**
 * Post a single inline comment (for testing or manual use)
 */
export async function postInlineComment(
  config: GitHubConfig,
  path: string,
  line: number,
  body: string,
  commitId: string
): Promise<{ id: number }> {
  const response = await fetch(
    `https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/comments`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${config.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        body,
        commit_id: commitId,
        path,
        line,
        side: 'RIGHT'
      })
    }
  );
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error: ${response.status} - ${error}`);
  }
  
  const data = await response.json() as { id: number };
  return { id: data.id };
}

/**
 * Update or create a PR comment (for summary updates)
 */
export async function upsertPRComment(
  config: GitHubConfig,
  body: string,
  marker: string = '<!-- ai-review-helper -->'
): Promise<{ id: number; created: boolean }> {
  // Find existing comment
  const commentsResponse = await fetch(
    `https://api.github.com/repos/${config.owner}/${config.repo}/issues/${config.pullNumber}/comments`,
    {
      headers: {
        'Authorization': `Bearer ${config.token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
  
  if (!commentsResponse.ok) {
    throw new Error(`Failed to fetch comments: ${commentsResponse.status}`);
  }
  
  const comments = await commentsResponse.json() as Array<{ id: number; body: string }>;
  const existingComment = comments.find(c => c.body.includes(marker));
  
  const fullBody = `${marker}\n\n${body}`;
  
  if (existingComment) {
    // Update existing comment
    const updateResponse = await fetch(
      `https://api.github.com/repos/${config.owner}/${config.repo}/issues/comments/${existingComment.id}`,
      {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${config.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ body: fullBody })
      }
    );
    
    if (!updateResponse.ok) {
      throw new Error(`Failed to update comment: ${updateResponse.status}`);
    }
    
    return { id: existingComment.id, created: false };
  } else {
    // Create new comment
    const createResponse = await fetch(
      `https://api.github.com/repos/${config.owner}/${config.repo}/issues/${config.pullNumber}/comments`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${config.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ body: fullBody })
      }
    );
    
    if (!createResponse.ok) {
      throw new Error(`Failed to create comment: ${createResponse.status}`);
    }
    
    const data = await createResponse.json() as { id: number };
    return { id: data.id, created: true };
  }
}

/**
 * Get changed files in a PR
 */
export async function getPRFiles(
  config: GitHubConfig
): Promise<Array<{ filename: string; patch: string; additions: number; deletions: number }>> {
  const response = await fetch(
    `https://api.github.com/repos/${config.owner}/${config.repo}/pulls/${config.pullNumber}/files`,
    {
      headers: {
        'Authorization': `Bearer ${config.token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    }
  );
  
  if (!response.ok) {
    throw new Error(`Failed to fetch PR files: ${response.status}`);
  }
  
  const files = await response.json() as Array<{ filename: string; patch?: string; additions: number; deletions: number }>;
  
  return files.map(f => ({
    filename: f.filename,
    patch: f.patch || '',
    additions: f.additions,
    deletions: f.deletions
  }));
}

/**
 * Rate limiter for GitHub API
 */
export class GitHubRateLimiter {
  private remaining: number = 5000;
  private resetTime: number = Date.now() + 3600000;
  
  async checkLimit(): Promise<boolean> {
    if (this.remaining < 10) {
      const waitTime = this.resetTime - Date.now();
      if (waitTime > 0) {
        console.warn(`GitHub API rate limit low. Waiting ${Math.ceil(waitTime / 1000)}s...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    return true;
  }
  
  updateFromHeaders(headers: Headers): void {
    const remaining = headers.get('x-ratelimit-remaining');
    const reset = headers.get('x-ratelimit-reset');
    
    if (remaining) this.remaining = parseInt(remaining, 10);
    if (reset) this.resetTime = parseInt(reset, 10) * 1000;
  }
}
