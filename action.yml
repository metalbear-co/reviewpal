name: 'ReviewPal'
description: 'AI-powered code review for any language using Gemini'
author: 'Han Kim'

branding:
  icon: 'eye'
  color: 'purple'

inputs:
  gemini_api_key:
    description: 'Google Gemini API key (REQUIRED)'
    required: true
  github_token:
    description: 'GitHub token for posting comments (defaults to GITHUB_TOKEN)'
    required: false
    default: ${{ github.token }}
  model:
    description: 'Gemini model to use'
    required: false
    default: 'gemini-2.5-pro'
  max_hunks:
    description: 'Maximum number of hunks to analyze (legacy mode only)'
    required: false
    default: '20'
  max_api_calls:
    description: 'Maximum API calls for triage pipeline (1 triage + N-1 deep reviews)'
    required: false
    default: '10'
  legacy_mode:
    description: 'Use legacy per-hunk analysis instead of triage pipeline'
    required: false
    default: 'false'
  comment_on_pr:
    description: 'Post analysis as PR comment'
    required: false
    default: 'true'
  format:
    description: 'Output format: friendly, json'
    required: false
    default: 'friendly'

outputs:
  total_files:
    description: 'Number of files analyzed'
  total_hunks:
    description: 'Number of hunks reviewed'
  ai_likelihood:
    description: 'Overall AI code likelihood (low/medium/high)'
  patterns_found:
    description: 'Number of patterns detected'
  high_complexity_hunks:
    description: 'Number of high-complexity hunks'
  analysis_markdown:
    description: 'Full analysis in markdown format'

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install dependencies
      shell: bash
      run: |
        cd ${{ github.action_path }}
        npm ci --production
    
    - name: Build
      shell: bash
      run: |
        cd ${{ github.action_path }}
        npm run build
    
    - name: Get PR diff
      shell: bash
      id: diff
      run: |
        git fetch origin ${{ github.base_ref }} --depth=1
        git diff origin/${{ github.base_ref }}...HEAD > /tmp/pr.diff
        echo "diff_file=/tmp/pr.diff" >> $GITHUB_OUTPUT
        echo "lines=$(wc -l < /tmp/pr.diff)" >> $GITHUB_OUTPUT
    
    - name: Skip if no diff
      if: steps.diff.outputs.lines == '0'
      shell: bash
      run: |
        echo "No changes detected, skipping analysis"
        echo "total_files=0" >> $GITHUB_OUTPUT
        echo "total_hunks=0" >> $GITHUB_OUTPUT
        exit 0
    
    - name: Run analysis
      shell: bash
      id: analyze
      env:
        GEMINI_API_KEY: ${{ inputs.gemini_api_key }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
        GH_TOKEN: ${{ inputs.github_token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_WORKSPACE: ${{ github.workspace }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
      run: |
        cd ${{ github.action_path }}

        # Build pipeline options
        PIPELINE_OPTS=""
        if [ "${{ inputs.legacy_mode }}" = "true" ]; then
          PIPELINE_OPTS="$PIPELINE_OPTS --legacy --max-hunks ${{ inputs.max_hunks }}"
        else
          PIPELINE_OPTS="$PIPELINE_OPTS --max-api-calls ${{ inputs.max_api_calls }}"
        fi

        # Run analysis (quiet mode to hide spinner)
        node dist/index.js ${{ steps.diff.outputs.diff_file }} \
          --format ${{ inputs.format }} \
          --quiet \
          --repo-root "$GITHUB_WORKSPACE" \
          --model ${{ inputs.model }} \
          $PIPELINE_OPTS > /tmp/analysis.md 2>&1 || true

        # Export for outputs
        echo "analysis_markdown<<EOF" >> $GITHUB_OUTPUT
        cat /tmp/analysis.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Also run JSON for structured data
        node dist/index.js ${{ steps.diff.outputs.diff_file }} \
          --format json \
          --quiet \
          --repo-root "$GITHUB_WORKSPACE" \
          --model ${{ inputs.model }} \
          $PIPELINE_OPTS > /tmp/analysis.json 2>&1 || echo '{"files":[],"totalHunks":0,"aiCodeLikelihood":"low"}' > /tmp/analysis.json
        
        # Extract key metrics safely
        echo "total_files=$(jq '.files | length // 0' /tmp/analysis.json)" >> $GITHUB_OUTPUT
        echo "total_hunks=$(jq '.totalHunks // 0' /tmp/analysis.json)" >> $GITHUB_OUTPUT
        echo "ai_likelihood=$(jq -r '.aiCodeLikelihood // "low"' /tmp/analysis.json)" >> $GITHUB_OUTPUT
    
    - name: Post inline comments and summary
      if: inputs.comment_on_pr == 'true' && github.event_name == 'pull_request' && steps.analyze.outputs.total_hunks != '0'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const fs = require('fs');
          const analysisJson = JSON.parse(fs.readFileSync('/tmp/analysis.json', 'utf8'));
          
          const EMOJI_MAP = {
            security: 'üîí',
            crash: 'üí•',
            'data-loss': 'üóëÔ∏è',
            performance: 'üêå'
          };
          
          // Collect all critical issues
          const allIssues = [];
          for (const file of analysisJson.files || []) {
            for (const hunk of file.hunks || []) {
              if (hunk.aiReview && hunk.aiReview.critical) {
                for (const issue of hunk.aiReview.critical) {
                  allIssues.push({
                    file: file.filename,
                    line: issue.line,
                    type: issue.type,
                    issue: issue.issue,
                    diffHash: hunk.hunk.fileDiffHash,
                    friendlySuggestion: issue.friendlySuggestion || issue.issue
                  });
                }
              }
            }
          }
          
          // Get PR summary (v3 triage result or legacy first hunk)
          let prSummary = '';
          if (analysisJson.triage && analysisJson.triage.prSummary) {
            prSummary = analysisJson.triage.prSummary;
          } else if (analysisJson.files && analysisJson.files[0] &&
              analysisJson.files[0].hunks && analysisJson.files[0].hunks[0] &&
              analysisJson.files[0].hunks[0].aiReview) {
            prSummary = analysisJson.files[0].hunks[0].aiReview.summary || '';
          }
          
          if (allIssues.length === 0) {
            // Post "no issues" message
            const marker = '<!-- reviewpal -->';
            let noIssuesMsg = `${marker}\n\n`;
            
            if (prSummary) {
              noIssuesMsg += `## üìã What is this PR about\n\n${prSummary}\n\n---\n\n`;
            }
            
            noIssuesMsg += `‚úÖ **No critical issues found**`;
            
            // Check for existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const botComment = comments.find(c => c.body && c.body.includes(marker));
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: noIssuesMsg
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: noIssuesMsg
              });
            }
            
            console.log('No critical issues found - posted confirmation');
            return;
          }
          
          // Post inline comments on each line and capture comment IDs
          const headSha = context.payload.pull_request.head.sha;
          const commentLinks = [];
          
          for (const item of allIssues) {
            try {
              const comment = await github.rest.pulls.createReviewComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: `${EMOJI_MAP[item.type] || '‚ö†Ô∏è'} **${item.type.toUpperCase()}**: ${item.friendlySuggestion}`,
                commit_id: headSha,
                path: item.file,
                line: item.line,
                side: 'RIGHT'
              });
              
              // Save comment link for summary (use #discussion_r{id} anchor format)
              const commentId = comment.data.id;
              const commentAnchor = `#discussion_r${commentId}`;
              
              commentLinks.push({
                type: item.type,
                url: commentAnchor,
                file: item.file,
                line: item.line
              });
            } catch (e) {
              console.log(`Failed to comment on ${item.file}:${item.line}:`, e.message);
            }
          }
          
          // Build summary
          let summary = '';

          // Add PR summary with styling
          if (prSummary) {
            summary += `## üìã What is this PR about\n\n`;
            summary += `${prSummary}\n\n`;
            summary += `---\n\n`;
          }

          if (commentLinks.length > 0) {
            // Build summary with numbered links to inline comments
            const issuesByType = {};
            let counter = 1;

            for (const item of commentLinks) {
              if (!issuesByType[item.type]) issuesByType[item.type] = [];
              issuesByType[item.type].push({
                num: counter++,
                url: item.url,
                file: item.file,
                line: item.line
              });
            }

            summary += `## üí° Suggestions\n\n`;
            summary += `| Category | Count | Details |\n`;
            summary += `|----------|-------|----------|\n`;

            const severityOrder = ['security', 'crash', 'data-loss', 'performance'];
            const sortedTypes = Object.keys(issuesByType).sort((a, b) => {
              return severityOrder.indexOf(a) - severityOrder.indexOf(b);
            });

            for (const type of sortedTypes) {
              const items = issuesByType[type];
              const emoji = EMOJI_MAP[type] || '‚ö†Ô∏è';
              const links = items.map(i => `[${i.num}](${i.url})`).join(' ');
              const typeLabel = type.toUpperCase().replace('-', ' ');
              summary += `| ${emoji} **${typeLabel}** | ${items.length} | ${links} |\n`;
            }
          } else {
            // Inline comments failed, list issues directly in summary
            summary += `## üí° Suggestions\n\n`;
            for (const item of allIssues) {
              const emoji = EMOJI_MAP[item.type] || '‚ö†Ô∏è';
              summary += `${emoji} **${item.type.toUpperCase()}** in \`${item.file}:${item.line}\`\n`;
              summary += `> ${item.friendlySuggestion}\n\n`;
            }
          }
          
          // Post or update summary comment
          const marker = '<!-- reviewpal -->';
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          
          const botComment = comments.find(c => c.body && c.body.includes(marker));
          const body = `${marker}\n\n${summary}`;
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
          }
    
    - name: Check complexity threshold
      if: inputs.fail_on_high_complexity == 'true'
      shell: bash
      run: |
        COMPLEXITY=$(jq '[.files[].hunks[].complexity.score // 0] | max // 0' /tmp/analysis.json)
        if (( $(echo "$COMPLEXITY > 7" | bc -l) )); then
          echo "::error::High complexity detected (score: $COMPLEXITY)"
          exit 1
        fi
